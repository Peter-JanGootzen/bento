use core;

use crate::kernel;

#[allow(unused_unsafe)]
#[macro_export]
macro_rules! c_str {
    ($arg:expr) => {
        concat!($arg, '\x00')
    };
}

/// Empty structure that uses libcore's `fmt::Write` trait to provide support for writing formatted
/// Arguments lists (as generated by the built-in `format_args!()` macro`)
pub struct KernelDebugWriter {}
impl core::fmt::Write for KernelDebugWriter {
    fn write_str(&mut self, message: &str) -> core::fmt::Result {
        #[allow(unused_unsafe)]
        unsafe {
            let ptr = kernel::ffi::__kmalloc((message.len() + 1) as kernel::raw::c_size_t, 0x90)
                as *mut kernel::raw::c_char; // 0x90 = GFP_KERNEL
            if ptr.is_null() {
                let msg = c_str!("Failed to allocate memory for dynamic printk()\n");
                let ptr = msg.as_ptr() as *const kernel::raw::c_char;
                kernel::ffi::printk(ptr);
            } else {
                core::ptr::copy(message.as_ptr(), ptr as *mut u8, message.len());
                core::ptr::write(ptr.offset(message.len() as isize), 0);
                kernel::ffi::printk(ptr);
                kernel::ffi::kfree(ptr as *const kernel::raw::c_void);
            }
        }

        core::result::Result::Ok(())
    }
}

#[macro_export]
macro_rules! print {
    // Static (zero-allocation) implementation that uses compile-time `concat!()` only
    ($fmt:expr) => ({
    use $crate::c_str;
	let msg = c_str!($fmt);
	let ptr = msg.as_ptr() as *const $crate::kernel::raw::c_char;
	unsafe {
	    $crate::kernel::ffi::printk(ptr);
	}
    });

    // Dynamic implementation that processes format arguments
    ($fmt:expr, $($arg:tt)*) => ({
	use ::core::fmt::Write;
	use $crate::io::KernelDebugWriter;

	let mut writer = KernelDebugWriter {};
	writer.write_fmt(format_args!($fmt, $($arg)*)).unwrap();
    });
}

#[macro_export]
macro_rules! println {
    ($fmt:expr)              => ({
        use $crate::print;
        //print!(concat!($fmt, "\n"))
        print!($fmt)
    });
    ($fmt:expr, $($arg:tt)+) => ({
        use $crate::print;
        //print!(concat!($fmt, "\n"), $($arg)*)
        print!($fmt, $($arg)*)
    });
}

#[macro_export]
macro_rules! printk {
    ($fmt:expr) => {{
        let msg = c_str!($fmt);
        let ptr = msg.as_ptr() as *const kernel::raw::c_char;
        unsafe {
            $crate::kernel::ffi::printk(ptr);
        }
    }};
}
